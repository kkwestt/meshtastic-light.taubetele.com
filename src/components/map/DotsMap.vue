<template>
  <div id="map" class="w-full h-full" @click="handleMapClick">
    <div class="node-counter">
      <span v-if="Object.keys(devices).length === 0"
        >üîÑ –ó–∞–≥—Ä—É–∑–∫–∞ –¥–∞–Ω–Ω—ã—Ö...</span
      >
      <span v-else>
        –£–∑–ª–æ–≤: {{ Object.keys(devices).length }} | –í–∏–¥–∏–º—ã—Ö: {{ pointsOnMap }}
      </span>
      <div class="update-indicator" v-if="updateInterval">
        <span class="update-dot"></span>
        <span class="update-text">–ê–≤—Ç–æ–æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ</span>
      </div>
    </div>
  </div>
</template>

<script setup>
import { ref, onMounted, onUnmounted, watch } from "vue";
import {
  MAP_CONFIG,
  MAP_PRESETS,
  UI_CONFIG,
  HARDWARE_MODELS,
  DEVICE_ROLES,
  REGIONS,
} from "../../utils/constants.js";
import { debounce, isPointInBounds } from "../../utils/helpers.js";
import { meshtasticApi } from "../../utils/api.js";

const emit = defineEmits(["infoOpen", "devicesCount"]);

let map, openedNodeId;

const handleMapClick = (event) => {
  const { nodeId } = event.target.dataset;
  if (nodeId) {
    // –û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–ª–∏–∫–∞ –ø–æ —É–∑–ª—É
  }
};

const devices = ref({});
const pointsOnMap = ref(0);
const filteredDevicesCache = ref(new Map());

const filterDevicesByBounds = (devices, bounds) => {
  if (!bounds || !devices) return [];

  const cacheKey = `${bounds.getSouthWest()}-${bounds.getNorthEast()}`;

  if (filteredDevicesCache.value.has(cacheKey)) {
    return filteredDevicesCache.value.get(cacheKey);
  }

  const filtered = [];
  const now = Date.now();

  for (const index in devices) {
    const device = devices[index];

    if (!device.latitude || !device.longitude) continue;

    const deviceTime = device.s_time;
    const timeDiffHours = (now - deviceTime) / (1000 * 60 * 60);
    if (timeDiffHours > 24) continue;

    if (!isPointInBounds(device.latitude, device.longitude, bounds)) continue;

    filtered.push(device);
  }

  filteredDevicesCache.value.set(cacheKey, filtered);

  if (filteredDevicesCache.value.size > 10) {
    const firstKey = filteredDevicesCache.value.keys().next().value;
    filteredDevicesCache.value.delete(firstKey);
  }

  return filtered;
};

const debouncedRenderBallons = debounce((devices, isUpdate) => {
  renderBallons(devices, isUpdate);
}, 2000);

const formatTime = (timestamp) => {
  if (!timestamp || timestamp === "undefined" || timestamp === 0) {
    return "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ";
  }

  const numTimestamp = Number(timestamp);
  if (isNaN(numTimestamp)) {
    return "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ";
  }

  let date;
  if (Math.abs(numTimestamp) > 10000) {
    date = new Date(numTimestamp);
  } else {
    date = new Date(numTimestamp * 1000);
  }

  if (isNaN(date.getTime())) {
    return "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ";
  }

  const now = new Date();
  const diffMs = now.getTime() - date.getTime();
  const diffSeconds = Math.floor(diffMs / 1000);
  const diffMinutes = Math.floor(diffSeconds / 60);
  const diffHours = Math.floor(diffMinutes / 60);
  const diffDays = Math.floor(diffHours / 24);

  if (diffSeconds < 60) {
    return `${diffSeconds} —Å–µ–∫ –Ω–∞–∑–∞–¥`;
  } else if (diffMinutes < 60) {
    return `${diffMinutes} –º–∏–Ω –Ω–∞–∑–∞–¥`;
  } else if (diffHours < 24) {
    return `${diffHours} —á –Ω–∞–∑–∞–¥`;
  } else if (diffDays < 7) {
    return `${diffDays} –¥–Ω –Ω–∞–∑–∞–¥`;
  } else {
    return date.toLocaleDateString("ru-RU", {
      day: "2-digit",
      month: "2-digit",
      year: "numeric",
      hour: "2-digit",
      minute: "2-digit",
    });
  }
};

const createBalloonContent = async (device, nodeId) => {
  let nodeInfoHtml = "";
  let positionInfoHtml = "";
  let telemetryInfoHtml = "";
  let textMessagesHtml = "";
  let mapReportHtml = "";

  try {
    const nodeInfo = await meshtasticApi.getNodeInfo(nodeId);
    if (nodeInfo && nodeInfo.data && nodeInfo.data.length > 0) {
      // –ë–µ—Ä–µ–º –ø–æ—Å–ª–µ–¥–Ω—é—é –∑–∞–ø–∏—Å—å (—Å–∞–º—É—é —Å–≤–µ–∂—É—é)
      const latestInfo = nodeInfo.data[0];
      const rawData = latestInfo.rawData;

      if (rawData) {
        nodeInfoHtml = `

    <div style="margin-top: 6px; padding-top: 6px; border-top: 1px solid #eee;">
    <div style="font-weight: bold;">–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ–± —É–∑–ª–µ: ${formatTime(
      latestInfo.timestamp
    )}</div>
    <div style="display: grid; grid-template-columns: auto 1fr; gap: 2px 8px; font-size: 11px; line-height: 1.2;">
    ${
      rawData.is_unmessagable
        ? `<span>–ü—Ä–∏–Ω–∏–º–∞–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏—è:</span><span>${
            !rawData.is_unmessagable ? "–î–∞" : "–ù–µ—Ç"
          }</span>`
        : ""
    }
    ${
      rawData.id
        ? `<span>ID:</span><span>${rawData.id} (${nodeId}) </span>`
        : ""
    }
    ${
      rawData.hw_model
        ? `<span>–ú–æ–¥–µ–ª—å:</span><span>${
            HARDWARE_MODELS[rawData.hw_model]
          }</span>`
        : ""
    }
    ${
      latestInfo.rxSnr !== undefined && latestInfo.rxRssi !== undefined
        ? latestInfo.rxSnr === 0 && latestInfo.rxRssi === 0
          ? `<span>–î–∞–Ω–Ω—ã–µ:</span><span>–ß–µ—Ä–µ–∑ MQTT</span>`
          : `<span>SNR:</span><span>${latestInfo.rxSnr} dB</span>
    <span>RSSI:</span><span>${latestInfo.rxRssi} dBm</span>`
        : ""
    }
    ${
      latestInfo.hopLimit !== undefined
        ? `<span>Hop Limit:</span><span>${
            7 - latestInfo.hopLimit === 0 ? "Direct" : 7 - latestInfo.hopLimit
          }</span>`
        : ""
    }
    ${
      latestInfo.gatewayId
        ? `<span>Gateway:</span><span>${latestInfo.gatewayId}</span>`
        : ""
    }
    </div>

    </div>
    `;
      }
    }
  } catch (error) {
    console.error("–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ–± —É–∑–ª–µ:", error);
  }

  try {
    const positionInfo = await meshtasticApi.getPositionInfo(nodeId);
    if (positionInfo && positionInfo.data && positionInfo.data.length > 0) {
      // –ë–µ—Ä–µ–º –ø–æ—Å–ª–µ–¥–Ω—é—é –∑–∞–ø–∏—Å—å (—Å–∞–º—É—é —Å–≤–µ–∂—É—é)
      const latestPosition = positionInfo.data[0];

      positionInfoHtml = `
    <div style="margin-top: 6px; padding-top: 6px; border-top: 1px solid #eee;">
    <div style="font-weight: bold; margin-bottom: 2px;">–î–∞–Ω–Ω—ã–µ –æ –ø–æ–∑–∏—Ü–∏–∏: ${formatTime(
      latestPosition.timestamp
    )}</div>

    <div style="display: grid; grid-template-columns: auto 1fr; gap: 2px 8px; font-size: 11px; line-height: 1.2;">
    ${
      latestPosition.rawData.latitude_i !== undefined
        ? `<span>–ö–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã:</span><span>${(
            latestPosition.rawData.latitude_i / 10000000
          ).toFixed(5)}, ${(
            latestPosition.rawData.longitude_i / 10000000
          ).toFixed(5)}</span>`
        : ""
    }
    ${
      latestPosition.rawData.altitude !== undefined
        ? `<span>–í—ã—Å–æ—Ç–∞:</span><span>${latestPosition.rawData.altitude} –º</span>`
        : ""
    }
    ${
      latestPosition.rawData.sats_in_view !== undefined
        ? `<span>–°–ø—É—Ç–Ω–∏–∫–∏:</span><span>${latestPosition.rawData.sats_in_view}</span>`
        : ""
    }
    ${
      latestPosition.rxSnr !== undefined && latestPosition.rxRssi !== undefined
        ? latestPosition.rxSnr === 0 && latestPosition.rxRssi === 0
          ? `<span>–î–∞–Ω–Ω—ã–µ:</span><span>–ß–µ—Ä–µ–∑ MQTT</span>`
          : `<span>SNR:</span><span>${latestPosition.rxSnr} dB</span>
    <span>RSSI:</span><span>${latestPosition.rxRssi} dBm</span>`
        : ""
    }
    ${
      latestPosition.hopLimit !== undefined
        ? `<span>Hop Limit:</span><span>${
            7 - latestPosition.hopLimit === 0
              ? "Direct"
              : 7 - latestPosition.hopLimit
          }</span>`
        : ""
    }
    ${
      latestPosition.gatewayId
        ? `<span>Gateway:</span><span>${latestPosition.gatewayId}</span>`
        : ""
    }
    </div>
    </div>
    `;
    }
  } catch (error) {
    console.error("–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ –ø–æ–∑–∏—Ü–∏–∏:", error);
  }

  try {
    const telemetryInfo = await meshtasticApi.getTelemetryInfo(nodeId);
    if (telemetryInfo && telemetryInfo.data && telemetryInfo.data.length > 0) {
      // –†–∞–∑–¥–µ–ª—è–µ–º –¥–∞–Ω–Ω—ã–µ –ø–æ —Ç–∏–ø–∞–º
      let deviceMetricsData = null;
      let environmentMetricsData = null;
      let latestDeviceMetrics = null;
      let latestEnvironmentMetrics = null;

      // –ò—â–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–µ –¥–∞–Ω–Ω—ã–µ –∫–∞–∂–¥–æ–≥–æ —Ç–∏–ø–∞
      for (const entry of telemetryInfo.data) {
        if (
          entry.rawData &&
          entry.rawData.type === "deviceMetrics" &&
          !latestDeviceMetrics
        ) {
          latestDeviceMetrics = entry;
          deviceMetricsData =
            entry.rawData.variant && entry.rawData.variant.value
              ? entry.rawData.variant.value
              : null;
        }
        if (
          entry.rawData &&
          entry.rawData.type === "environmentMetrics" &&
          !latestEnvironmentMetrics
        ) {
          latestEnvironmentMetrics = entry;
          environmentMetricsData =
            entry.rawData.variant && entry.rawData.variant.value
              ? entry.rawData.variant.value
              : null;
        }
      }

      // –§–æ—Ä–º–∏—Ä—É–µ–º HTML –¥–ª—è –¥–∞–Ω–Ω—ã—Ö —É–∑–ª–∞ (deviceMetrics)
      let deviceMetricsHtml = "";
      if (latestDeviceMetrics && deviceMetricsData) {
        deviceMetricsHtml = `
    <div style="margin-top: 6px; padding-top: 6px; border-top: 1px solid #eee;">
    <div style="font-weight: bold; margin-bottom: 2px;">–î–∞–Ω–Ω—ã–µ —É–∑–ª–∞: ${formatTime(
      latestDeviceMetrics.timestamp
    )}</div>

    <div style="display: grid; grid-template-columns: auto 1fr; gap: 2px 8px; font-size: 11px; line-height: 1.2;">
    ${
      deviceMetricsData.battery_level !== undefined
        ? `<span>–ë–∞—Ç–∞—Ä–µ—è:</span><span>${deviceMetricsData.battery_level}%</span>`
        : ""
    }
    ${
      deviceMetricsData.voltage !== undefined
        ? `<span>–ù–∞–ø—Ä—è–∂–µ–Ω–∏–µ:</span><span>${deviceMetricsData.voltage.toFixed(
            2
          )} –í</span>`
        : ""
    }
    ${
      deviceMetricsData.channel_utilization !== undefined
        ? `<span>–ó–∞–≥—Ä—É–∑–∫–∞ –∫–∞–Ω–∞–ª–∞:</span><span>${deviceMetricsData.channel_utilization.toFixed(
            1
          )}%</span>`
        : ""
    }
    ${
      deviceMetricsData.air_util_tx !== undefined
        ? `<span>–≠—Ñ–∏—Ä TX:</span><span>${deviceMetricsData.air_util_tx.toFixed(
            1
          )}%</span>`
        : ""
    }
    ${
      deviceMetricsData.uptime_seconds !== undefined
        ? `<span>–í—Ä–µ–º—è —Ä–∞–±–æ—Ç—ã:</span><span>${Math.floor(
            deviceMetricsData.uptime_seconds / 3600
          )}—á ${Math.floor(
            (deviceMetricsData.uptime_seconds % 3600) / 60
          )}–º</span>`
        : ""
    }
    ${
      latestDeviceMetrics.rxSnr !== undefined &&
      latestDeviceMetrics.rxRssi !== undefined
        ? latestDeviceMetrics.rxSnr === 0 && latestDeviceMetrics.rxRssi === 0
          ? `<span>–î–∞–Ω–Ω—ã–µ:</span><span>–ß–µ—Ä–µ–∑ MQTT</span>`
          : `<span>SNR:</span><span>${latestDeviceMetrics.rxSnr} dB</span>
    <span>RSSI:</span><span>${latestDeviceMetrics.rxRssi} dBm</span>`
        : ""
    }
    ${
      latestDeviceMetrics.hopLimit !== undefined
        ? `<span>Hop Limit:</span><span>${
            7 - latestDeviceMetrics.hopLimit === 0
              ? "Direct"
              : 7 - latestDeviceMetrics.hopLimit
          }</span>`
        : ""
    }
    ${
      latestDeviceMetrics.gatewayId
        ? `<span>Gateway:</span><span>${latestDeviceMetrics.gatewayId}</span>`
        : ""
    }
    </div>
    </div>
    `;
      }

      // –§–æ—Ä–º–∏—Ä—É–µ–º HTML –¥–ª—è —Å–µ–Ω—Å–æ—Ä–æ–≤ (environmentMetrics)
      let environmentMetricsHtml = "";
      if (latestEnvironmentMetrics && environmentMetricsData) {
        environmentMetricsHtml = `
    <div style="margin-top: 6px; padding-top: 6px; border-top: 1px solid #eee;">
    <div style="font-weight: bold; margin-bottom: 2px;">–°–µ–Ω—Å–æ—Ä—ã: ${formatTime(
      latestEnvironmentMetrics.timestamp
    )}</div>

    <div style="display: grid; grid-template-columns: auto 1fr; gap: 2px 8px; font-size: 11px; line-height: 1.2;">
    ${
      environmentMetricsData.temperature !== undefined
        ? `<span>–¢–µ–º–ø–µ—Ä–∞—Ç—É—Ä–∞:</span><span>${environmentMetricsData.temperature.toFixed(
            1
          )}¬∞C</span>`
        : ""
    }
    ${
      environmentMetricsData.lux !== undefined
        ? `<span>–û—Å–≤–µ—â–µ–Ω–Ω–æ—Å—Ç—å:</span><span>${environmentMetricsData.lux} lux</span>`
        : ""
    }
    ${
      environmentMetricsData.humidity !== undefined
        ? `<span>–í–ª–∞–∂–Ω–æ—Å—Ç—å:</span><span>${environmentMetricsData.humidity.toFixed(
            1
          )}%</span>`
        : ""
    }
    ${
      environmentMetricsData.pressure !== undefined
        ? `<span>–î–∞–≤–ª–µ–Ω–∏–µ:</span><span>${environmentMetricsData.pressure.toFixed(
            1
          )} hPa</span>`
        : ""
    }
    ${
      latestEnvironmentMetrics.rxSnr !== undefined &&
      latestEnvironmentMetrics.rxRssi !== undefined
        ? latestEnvironmentMetrics.rxSnr === 0 &&
          latestEnvironmentMetrics.rxRssi === 0
          ? `<span>–î–∞–Ω–Ω—ã–µ:</span><span>–ß–µ—Ä–µ–∑ MQTT</span>`
          : `<span>SNR:</span><span>${latestEnvironmentMetrics.rxSnr} dB</span>
    <span>RSSI:</span><span>${latestEnvironmentMetrics.rxRssi} dBm</span>`
        : ""
    }
    ${
      latestEnvironmentMetrics.hopLimit !== undefined
        ? `<span>Hop Limit:</span><span>${
            7 - latestEnvironmentMetrics.hopLimit === 0
              ? "Direct"
              : 7 - latestEnvironmentMetrics.hopLimit
          }</span>`
        : ""
    }
    ${
      latestEnvironmentMetrics.gatewayId
        ? `<span>Gateway:</span><span>${latestEnvironmentMetrics.gatewayId}</span>`
        : ""
    }
    </div>
    </div>
    `;
      }

      telemetryInfoHtml = deviceMetricsHtml + environmentMetricsHtml;
    }
  } catch (error) {
    console.error("–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —Ç–µ–ª–µ–º–µ—Ç—Ä–∏–∏:", error);
  }

  try {
    const textMessages = await meshtasticApi.getTextMessages(nodeId);
    if (textMessages && textMessages.data && textMessages.data.length > 0) {
      // –ë–µ—Ä–µ–º –ø–æ—Å–ª–µ–¥–Ω–µ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ (—Å–∞–º–æ–µ —Å–≤–µ–∂–µ–µ)
      const latestMessage = textMessages.data[0];
      const rawData = latestMessage.rawData;

      if (rawData && rawData.text) {
        textMessagesHtml = `
    <div style="margin-top: 6px; padding-top: 6px; border-top: 1px solid #eee;">
    <div style="font-weight: bold; margin-bottom: 2px;">–ü–æ—Å–ª–µ–¥–Ω–µ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ: ${formatTime(
      latestMessage.timestamp
    )}</div>

    <div style="display: grid; grid-template-columns: auto 1fr; gap: 2px 8px; font-size: 11px; line-height: 1.2;">
    <span>–¢–µ–∫—Å—Ç:</span><span style="word-break: break-word;">${
      rawData.text
    }</span>

    ${
      latestMessage.to !== undefined
        ? `<span>–ö–æ–º—É:</span><span>${
            latestMessage.to === 4294967295 ? "–í—Å–µ–º" : latestMessage.to
          }</span>`
        : ""
    }
    ${
      latestMessage.rxSnr !== undefined && latestMessage.rxRssi !== undefined
        ? latestMessage.rxSnr === 0 && latestMessage.rxRssi === 0
          ? `<span>–î–∞–Ω–Ω—ã–µ:</span><span>–ß–µ—Ä–µ–∑ MQTT</span>`
          : `<span>SNR:</span><span>${latestMessage.rxSnr} dB</span>
    <span>RSSI:</span><span>${latestMessage.rxRssi} dBm</span>`
        : ""
    }
    ${
      latestMessage.hopLimit !== undefined
        ? `<span>Hop Limit:</span><span>${
            7 - latestMessage.hopLimit === 0
              ? "Direct"
              : 7 - latestMessage.hopLimit
          }</span>`
        : ""
    }
    ${
      latestMessage.gatewayId
        ? `<span>Gateway:</span><span>${latestMessage.gatewayId}</span>`
        : ""
    }
    </div>
    </div>
    `;
      }
    }
  } catch (error) {
    console.error("–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —Ç–µ–∫—Å—Ç–æ–≤—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π:", error);
  }

  try {
    const mapReportInfo = await meshtasticApi.getMapReportInfo(nodeId);
    if (mapReportInfo && mapReportInfo.data && mapReportInfo.data.length > 0) {
      // –ë–µ—Ä–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–π –æ—Ç—á–µ—Ç (—Å–∞–º—ã–π —Å–≤–µ–∂–∏–π)
      const latestReport = mapReportInfo.data[0];
      const rawData = latestReport.rawData;

      if (rawData) {
        mapReportHtml = `
    <div style="margin-top: 6px; padding-top: 6px; border-top: 1px solid #eee;">
    <div style="font-weight: bold; margin-bottom: 2px;">–û—Ç—á–µ—Ç –∫–∞—Ä—Ç—ã: ${formatTime(
      latestReport.timestamp
    )}</div>

    <div style="display: grid; grid-template-columns: auto 1fr; gap: 2px 8px; font-size: 11px; line-height: 1.2;">
    ${
      rawData.decoded.role !== undefined
        ? `<span>–†–æ–ª—å:</span><span>${DEVICE_ROLES[rawData.decoded.role]}</span>`
        : ""
    }
    ${
      rawData.decoded.hw_model !== undefined
        ? `<span>–ú–æ–¥–µ–ª—å:</span><span>${
            HARDWARE_MODELS[rawData.decoded.hw_model]
          }</span>`
        : ""
    }
    ${
      rawData.decoded.firmware_version
        ? `<span>–ü—Ä–æ—à–∏–≤–∫–∞:</span><span>${rawData.decoded.firmware_version}</span>`
        : ""
    }
         ${
           rawData.decoded.region !== undefined
             ? `<span>–†–µ–≥–∏–æ–Ω:</span><span>${
                 REGIONS[rawData.decoded.region] || rawData.decoded.region
               }</span>`
             : ""
         }
    ${
      rawData.decoded.modem_preset !== undefined
        ? `<span>–ü—Ä–µ—Å–µ—Ç –º–æ–¥–µ–º–∞:</span><span>${rawData.decoded.modem_preset}</span>`
        : ""
    }
    ${
      rawData.decoded.has_default_channel !== undefined
        ? `<span>–ö–∞–Ω–∞–ª –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é:</span><span>${
            rawData.decoded.has_default_channel ? "–î–∞" : "–ù–µ—Ç"
          }</span>`
        : ""
    }
        ${
          rawData.decoded.numOnlineLocalNodes !== undefined
            ? `<span>–†—è–¥–æ–º –¥—Ä—É–≥–∏—Ö —É—Å—Ç—Ä–æ–π—Å—Ç–≤:</span><span>${rawData.decoded.numOnlineLocalNodes}</span>`
            : ""
        }
    ${
      latestReport.rxSnr !== undefined && latestReport.rxRssi !== undefined
        ? latestReport.rxSnr === 0 && latestReport.rxRssi === 0
          ? `<span>–î–∞–Ω–Ω—ã–µ:</span><span>–ß–µ—Ä–µ–∑ MQTT</span>`
          : `<span>SNR:</span><span>${latestReport.rxSnr} dB</span>
    <span>RSSI:</span><span>${latestReport.rxRssi} dBm</span>`
        : ""
    }

    ${
      latestReport.gatewayId
        ? `<span>Gateway:</span><span>${latestReport.gatewayId}</span>`
        : ""
    }
    </div>
    </div>
    `;
      }
    }
  } catch (error) {
    console.error("–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –æ—Ç—á–µ—Ç–∞ –∫–∞—Ä—Ç—ã:", error);
  }

  return `
    <div style="max-width: 350px; font-size: 12px;">

    ${nodeInfoHtml}
    ${positionInfoHtml}
    ${telemetryInfoHtml}
    ${textMessagesHtml}
    ${mapReportHtml}
    </div>
  `;
};

const renderPath = async (nodeId) => {
  if (!nodeId) return;

  try {
    const gpsData = await meshtasticApi.getGpsTrack(nodeId);

    if (!gpsData || !gpsData.length) return;

    const polyline = new ymaps.Polyline(
      gpsData.map(({ latitudeI, longitudeI }) => [
        latitudeI / 10000,
        longitudeI / 10000,
      ]),
      {},
      {
        strokeColor: MAP_CONFIG.PATH_STROKE_COLOR,
        strokeWidth: MAP_CONFIG.PATH_STROKE_WIDTH,
      }
    );

    map.geoObjects.add(polyline);
  } catch (error) {
    console.error("–û—à–∏–±–∫–∞ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è –ø—É—Ç–∏:", error);
  }
};

const renderBallons = (devices, isUpdate = false) => {
  try {
    if (!devices || Object.keys(devices).length === 0) {
      return;
    }

    if (isUpdate) {
      clearDeviceMarkers();
    }

    const placemarks = [];
    const state = map.action.getCurrentState();
    const now = Date.now();

    for (const index in devices) {
      const device = devices[index];
      const nodeId = device.device_id || device.hex_id || device.id || index;

      if (!device.latitude || !device.longitude) continue;

      const deviceTime = device.s_time;
      const timeDiffHours = (now - deviceTime) / (1000 * 60 * 60);

      if (timeDiffHours > 24) continue;

      const bounds = map.getBounds();
      if (!isPointInBounds(device.latitude, device.longitude, bounds)) continue;

      let presetcolor;
      if (timeDiffHours < 6) {
        presetcolor = MAP_PRESETS.ONLINE;
      } else {
        presetcolor = MAP_PRESETS.INACTIVE;
      }

      const timestampfooter = formatTime(device.s_time);

      const placemark = new window.ymaps.Placemark(
        [device.latitude, device.longitude],
        {
          iconContent: device.shortName,
          balloonContentHeader: device.longName + " (" + device.shortName + ")",
          balloonContentBody: `
    <div style="max-width: 350px; font-size: 12px;">

    <div style="margin-top: 8px; color: #666;">üîÑ –ó–∞–≥—Ä—É–∑–∫–∞ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ–± —É–∑–ª–µ...</div>
    </div>
    `,
          balloonContentFooter: `Updated: ${timestampfooter}`,
          clusterCaption: `Node: <strong>${
            device.shortName || device.short_name || nodeId
          }</strong>`,
          nodeId,
        },
        { preset: `${presetcolor}` }
      );

      placemark.events.add("balloonopen", async (event) => {
        const nodeId =
          event.originalEvent.currentTarget.properties._data.nodeId;
        openedNodeId = nodeId;
        renderPath(openedNodeId);

        // –ó–∞–≥—Ä—É–∂–∞–µ–º –ø–æ–ª–Ω–æ–µ —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ –±–∞–ª–ª—É–Ω–∞
        try {
          const fullContent = await createBalloonContent(device, nodeId);
          placemark.properties.set("balloonContentBody", fullContent);
        } catch (error) {
          console.error("–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —Å–æ–¥–µ—Ä–∂–∏–º–æ–≥–æ –±–∞–ª–ª—É–Ω–∞:", error);
          placemark.properties.set(
            "balloonContentBody",
            `
    <div style="max-width: 350px; font-size: 12px;">
    <div style="margin-top: 8px; color: #f44336;">‚ùå –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –¥–∞–Ω–Ω—ã—Ö</div>
    </div>
    `
          );
        }
      });

      placemarks.push(placemark);
    }

    if (state.zoom > MAP_CONFIG.MIN_ZOOM_FOR_INDIVIDUAL_MARKERS) {
      placemarks.forEach((p) => {
        map.geoObjects.add(p);

        if (openedNodeId && p.properties._data.nodeId === openedNodeId) {
          const length = map.geoObjects.getLength();
          const geometryObject = map.geoObjects.get(length - 1);

          geometryObject.balloon.events.add("beforeuserclose", () => {
            openedNodeId = null;
          });

          geometryObject.balloon.open(undefined, undefined, {
            balloonAutoPan: false,
          });
        }
      });

      pointsOnMap.value = placemarks.length;
      return;
    }

    const clusterer = new ymaps.Clusterer({
      preset: MAP_PRESETS.CLUSTER,
      gridSize: MAP_CONFIG.CLUSTER_GRID_SIZE,
      groupByCoordinates: false,
      clusterDisableClickZoom: true,
      clusterHideIconOnBalloonOpen: false,
      geoObjectHideIconOnBalloonOpen: false,
    });

    clusterer.add(placemarks);
    map.geoObjects.add(clusterer);
    pointsOnMap.value = placemarks.length;
  } catch (error) {
    console.error("‚ùå –û—à–∏–±–∫–∞ –≤ renderBallons:", error);
    pointsOnMap.value = 0;
  }
};

const fetchDevicesData = async () => {
  try {
    const response = await fetch("https://meshtasticback.taubetele.com/dots");
    const data = await response.json();

    if (data && data.data) {
      devices.value = data.data;
      const count = Object.keys(data.data).length;
      emit("devicesCount", count);

      if (typeof debouncedRenderBallons === "function") {
        debouncedRenderBallons(devices.value, false);
      }
    } else {
      devices.value = {};
      emit("devicesCount", 0);
    }
  } catch (error) {
    console.error("‚ùå –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –¥–∞–Ω–Ω—ã—Ö —É—Å—Ç—Ä–æ–π—Å—Ç–≤:", error);
    devices.value = {};
    emit("devicesCount", 0);
  }
};

let updateInterval = null;

const startDataUpdates = () => {
  if (updateInterval) {
    clearInterval(updateInterval);
  }

  updateInterval = setInterval(async () => {
    await updateDevicesData();
  }, 30000);
};

const stopDataUpdates = () => {
  if (updateInterval) {
    clearInterval(updateInterval);
    updateInterval = null;
  }
};

const clearDeviceMarkers = () => {
  if (!map) return;
  map.geoObjects.removeAll();
  pointsOnMap.value = 0;
};

const updateDevicesData = async () => {
  try {
    const response = await fetch("https://meshtasticback.taubetele.com/dots");
    const data = await response.json();

    if (data && data.data) {
      devices.value = data.data;
      const count = Object.keys(data.data).length;
      emit("devicesCount", count);

      if (typeof debouncedRenderBallons === "function") {
        debouncedRenderBallons(devices.value, true);
      }
    }
  } catch (error) {
    console.error("‚ùå –û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö —É—Å—Ç—Ä–æ–π—Å—Ç–≤:", error);
  }
};

onMounted(async () => {
  startDataUpdates();

  onUnmounted(() => {
    stopDataUpdates();
  });

  const renderSelfBallon = (shouldSetCenter) => {
    if (!shouldSetCenter) return;

    ymaps.geolocation
      .get({
        provider: "auto",
        mapStateAutoApply: false,
        timeout: 10000,
      })
      .then(function (result) {
        try {
          result.geoObjects.options.set("preset", MAP_PRESETS.GEOLOCATION);
          result.geoObjects
            .get(0)
            .properties.set({ balloonContentBody: "–í—ã –∑–¥–µ—Å—å!" });
          map.geoObjects.add(result.geoObjects);

          if (shouldSetCenter) {
            map.setCenter(
              result.geoObjects.get(0).geometry.getCoordinates(),
              10
            );
          }
        } catch (error) {
          if (shouldSetCenter) {
            map.setCenter(MAP_CONFIG.DEFAULT_CENTER, MAP_CONFIG.DEFAULT_ZOOM);
          }
        }
      })
      .catch(function (error) {
        if (shouldSetCenter) {
          map.setCenter(MAP_CONFIG.DEFAULT_CENTER, MAP_CONFIG.DEFAULT_ZOOM);
        }
      });
  };

  const initYMap = () => {
    map = new ymaps.Map("map", {
      center: MAP_CONFIG.DEFAULT_CENTER,
      zoom: MAP_CONFIG.DEFAULT_ZOOM,
    });
    map.controls.remove("fullscreenControl");
    map.controls.remove("searchControl");

    let infoButton = new ymaps.control.Button("INFO");
    map.controls.add(infoButton, {
      selectOnClick: false,
      float: "left",
      floatIndex: 1,
    });
    infoButton.events.add("click", function () {
      emit("infoOpen");
    });

    const onBoundsChange = () => {
      filteredDevicesCache.value.clear();
      map.geoObjects.removeAll();
      pointsOnMap.value = 0;
      renderBallons(devices?.value);
    };

    map.events.add(
      "boundschange",
      debounce(onBoundsChange, UI_CONFIG.DEBOUNCE_MAP_DELAY)
    );

    map.events.add("zoomchange", () => {
      onBoundsChange();
    });
  };

  const init = async () => {
    initYMap();
    renderSelfBallon(true);
    await fetchDevicesData();
    debouncedRenderBallons(devices?.value);

    watch(devices, (newDevices) => {
      map.geoObjects?.removeAll();
      pointsOnMap.value = 0;
      filteredDevicesCache.value.clear();
      renderSelfBallon();
      debouncedRenderBallons(newDevices);
      renderPath(openedNodeId);
    });
  };

  if (window.ymaps) {
    window.ymaps.ready(() => init().catch(console.error));
  } else {
    const script = document.createElement("script");
    script.src = "https://api-maps.yandex.ru/2.1/?lang=ru_RU";
    script.async = true;

    script.onload = () => {
      if (window.ymaps) {
        window.ymaps.ready(() => init().catch(console.error));
      }
    };

    script.onerror = () => {
      console.error("‚ùå –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ Yandex Maps API");
    };

    document.head.appendChild(script);
  }
});
</script>

<style lang="scss">
.node-counter {
  position: absolute;
  bottom: 35px;
  left: 7px;
  background: rgba(255, 255, 255, 0.9);
  backdrop-filter: blur(5px);
  padding: 8px 12px;
  border-radius: 6px;
  font-size: 14px;
  font-weight: 600;
  color: #333;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
  border: 1px solid rgba(0, 0, 0, 0.1);
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
  z-index: 1000;
  user-select: none;
  pointer-events: none;
}

.update-indicator {
  display: flex;
  align-items: center;
  gap: 6px;
  margin-top: 4px;
  font-size: 11px;
  color: #666;
}

.update-dot {
  width: 6px;
  height: 6px;
  background: #4caf50;
  border-radius: 50%;
  animation: pulse 2s infinite;
}

.update-text {
  font-size: 10px;
}

@keyframes pulse {
  0% {
    opacity: 1;
  }
  40% {
    opacity: 0.5;
  }
  100% {
    opacity: 1;
  }
}
</style>
